
// -*- mode: c++; mode: visual-line; mode: flyspell; fill-column: 100000 -*-
/***************************************************************************
 *  doc/tutorial.dox
 *
 *  Usage Tutorial for STXXL
 *
 *  Part of the STXXL. See http://stxxl.sourceforge.net
 *
 *  Copyright (C) 2013 Timo Bingmann <tb@panthema.net>
 *
 *  Distributed under the Boost Software License, Version 1.0.
 *  (See accompanying file LICENSE_1_0.txt or copy at
 *  http://www.boost.org/LICENSE_1_0.txt)
 **************************************************************************/

namespace stxxl {

/** \page tutorial Tutorials

This tutorial on the Standard Templete Library for Very Large Datasets (STXXL) is meant as an introduction to all those who use the STXXL for the first time - just basic knowledge in C++ is required. Note that the focus of this tutorial is on the most importatant features and is by no means exhaustive. If necessary, we refer to more advanced functionality which would go however beyond the scope of this introduction. 

Why do i need the STXXL? Imagine a situation where you want to work with a std::vector which does not fit into the internal memory completely. That is precisely the situation where the STXXL container 
stxxl::vector solves the issue. The practical part about it: Stxxl containers work in a similar way as their internal counterparts from the Standard Template Library (STL) so that parts of this tutorial may 
sound familiar to you. Naturally, the vector container is just an example - the same applies to other data structures.

Before running the STXXL for the first time you may check \ref install_unix.

# Available tutorials on STXXL Containers

This section introduces in all currently available STXXL containers.
The practical part about it: STXXL containers work in a similar way as their internal counterparts from the Standard Template Library (STL) so that parts of this tutorial may sound familiar to you.

- \subpage tutorial_vector "stxxl::vector Tutorial"
- \subpage tutorial_stack "stxxl::stack Tutorial"
- \subpage tutorial_queue "stxxl::queue Tutorial"
- \subpage tutorial_deque "stxxl::deque Tutorial"
- \subpage tutorial_pqueue "stxxl::priority_queue Tutorial"
- \subpage tutorial_map "stxxl::map Tutorial"
- \subpage tutorial_matrix "stxxl::matrix Tutorial"

For more information on the structure, the internal design and time / space complexity of the provided operations, see \ref design_stl.

*/

/** \page tutorial_vector Vector Tutorial

This page introduces into the usage of stxxl::vector container (to learn more about the structure of stxxl::vector, see section \ref design_vector).

### Creating a STXXL vector

Before we can use a STXXL vector, we first have to define and then to instantiate a vector object.
To manage the configuration of the vector type we use the generator template. A minimal configuration is shown below - as one can see the value_type (integer in our case) is the only only stricly neccessary 
parameter. See \ref design_vector_generator for additional configuration parameters and information.

\code
typedef stxxl::VECTOR_GENERATOR<int>::result vector;
vector my_vector;  // creates empty vector 
\endcode

### Fill in values

As the STXXL vector supports many (but not all) operations the STL vector supports as well, we can fill the vector by calling push_back() which appends a new value at the end:

\code
for (int i = 0; i < 10*1024*1024; i++) 
{
  my_vector.push_back(i);
}
\endcode

### Access elements

To read and/or modify the values of a STXXL vector, simply use the []-operator - equivalent to STL vector:

\code
std::cout << "element at position 99: " << my_vector[99] << std::endl;
my_vector[99] = 0;  // zeroing element at position 99
\endcode

In addition, the STXXL vector provides different iterators to advance the vector which can be used as follows:

\code
// create iterator which starts at the beginning of my_vector
vector::iterator iter = my_vector.begin();
// access an element
std::cout << "first element: " << *iter << std::endl;
// go to next element
iter++;
\endcode

Alongside with the many advantages of iterators, there are several things which need to bear in mind when using them. Details are described in \ref design_vector_notes.

### Erase elements

The operation pop_back() removes the last element of the vector (without returning it). The following code snippet is emptying my_vector:

\code
// empty() returns true, if the vector is empty
while (!my_vector.empty()) {
  my_vector.pop_back();
}
\endcode


### Determine size / Check whether vector is empty

To determine the number of elements a vector currently stores, call size():
\code
std::cout << "size of vector: " << my_vector.size() << std::endl;
\endcode

To check if the vector is empty, call the empty() function which returns true in that case:
\code
std::cout << "vector empty? " << my_vector.empty() << std::endl;
\endcode


### A minimal working example of STXXL's vector

\snippet vector_minimal1.cpp example

The following links refer to more extensive STXXL vector examples:

\subpage count_even_numbers_example "Example 1 - Count Even Numbers"

\subpage phonebills_example "Example 2 - Phonebills Example"
*/

/*! \page count_even_numbers_example Vector Example 1 - Count Even Numbers 
\snippet vector1.cpp example
*/

/*! \page phonebills_example Vector Example 2 - Phonebills
\snippet phonebills.cpp example
*/

*/

/*! \page tutorial_stack Stack Tutorial

This page introduces into the stxxl::stack container (to learn more about the structure of stxxl::stack, see section \ref design_stack).

STXXL stacks are last in first out (LIFO), i.e. inserting and extracting elements are only allowed from one end of the container and the element on top is the element added most recently.

### Creating a STXXL stack

Before using a STXXL stack, we initially have to define and then to instantiate a stack object. To manage the configuration of the stack type we used the generator template. A minimal configuration is shown below - as one can see the value_type (integer in our case) is the only stricly neccessary parameter. See [TODO ref design_stack_generator] for additional configuration parameters and information.

\code
typedef stxxl::STACK_GENERATOR<int>::result stack;
stack my_stack;
\endcode

Hint: STXXL stack provides specialized implementations for a certain access pattern. If the access pattern is known before, such a customization might gain a significant speedup. 
The default stack is stxxl::normal_stack which is the best for a random sequence of push'es and pop's. See [TODO] for more details. 

### Insert / Access / Remove elements 

To insert an element on top of the stack call push():

\code
my_stack.push(7);
my_stack.push(2);
my_stack.push(5);
// stack from bottom to top: |7|2|5|
\endcode

To access the top element call top():

\code
std::cout << "element on top of stack is: " << my_stack.top << std::endl;  // prints out 5
\endcode

To remove the top element call pop().

\code
my_stack.pop();  // removes element 5
\endcode

### Determine size  / Check whether stack is empty

To determine the size (i.e. the number of elements) of stack instance, call size(): 

\code
std::cout << "size of stack: " << my_stack.size() << std::endl;
\endcode

To check if the stack is empty, call empty() which returns true in case of emptyness:

\code
while (!my_stack.empty()) 
{
  // do something
}
\endcode

### A minimal working example of STXXL's stack

\snippet stack_minimal1.cpp example

The following page refers to more comprehensive grow-shrink-stack example.

\subpage grow_shrink_stack_example "Stack Example 1 - Grow-Shrink-Stack"

\page grow_shrink_stack_example Stack Example 1 - Grow-Shrink-Stack

\snippet stack1.cpp example

*/

/*! \page tutorial_queue Queue Tutorial

This page introduces into the stxxl::queue Container (to learn more about the structure of stxxl::stack, see section \ref design_queue).

### Creating a STXXL queue

Before using a STXXL queue, we initially have to define and then to instantiate a queue object. The implementation holds the head and the tail blocks in the main memory. Prefetch and write block pools might be used to overlap I/O and computation during queue operations. A minimal configuration is shown below - the value_type (integer in our example case) is the only stricly neccessary parameter. 
The default configuration initializes a write_pool and a prefetch_pool of size 1. 

\code 
typedef stxxl::queue<int> queue;
// create queue object with default parameters: 
// write_pool size = ?, prefetch_pool size = 1, blocks2prefetch = number of blocks in the prefetch pool (i.e. 1)
queue my_queue;
\endcode

The STXXL queue implementation provides three different types of constructors to customize your individual caching. See [TODO ref design_queue] for more details.
Additional optional template parameters are block_size, allocation_strategy, size_type, see [TODO ref ...] for further details.

### Insert / Access / Delete elements

To insert a new value at the beginning of the queue, call \b push().
Accessing elements are possible on both endings of the queue, \b back() returns the value at the beginning, \b front() returns the value at the end. Deleting a value by pop() erases the first inserted element.

\code
my_queue.push(5);  // queue now stores: |5| 
my_queue.push(9);  // queue now stores: |9|5|
my_queue.push(1);  // queue now stores: |1|9|5|
x = my_queue.back();  // x = 1  
y = my_queue.front();  // y = 5  
my_queue.pop();  // queue now stores: |1|9|
\endcode

### Determine size / Check whether queue is empty

To determine the number of elements a queue currently stores, call size():

\code
std::cout << "size of queue: " << my_queue.size() << std::endl;
\endcode

To check if the queue is empty, call empty() which returns true in that case:

\code
std::cout << "queue empty? " << my_queue.empty() << std::endl;
\endcode

### A minimal working example of STXXL's queue

\snippet queue_minimal1.cpp example

The following page refers to more comprehensive stxxl queue example.

\subpage queue_scanning_example "Example 1 - Queue Scanning"

\page queue_scanning_example Queue Example 1 - Queue Scanning

\snippet queue1.cpp example

*/




/*! \page tutorial_deque Deque Tutorial

This page introduces into the stxxl::deque container (to learn more about the structure of stxxl::deque, see section \ref design_deque).

The acronym Deque stands for "double-ended-queue", that means elements can be accessed, inserted and deleted on both ends of the data structure - in contrast to the stxxl::queue (see \ref tutorial_queue), 
where that's only possible on one of the two endings. 


### Creating a STXXL deque

To create a stxxl::deque object, only the data value type must be specified:

\code
typedef stxxl::deque<int> deque;
deque my_deque;
\endcode

See \ref TODO for additional template parameter details. 

### Insert elements

Inserting elements is possible at the start (by calling the push_front() function) as well as the end (by calling the push_back() function) of the deque.

\code
my_deque.push_front(2);
my_deque.push_front(11);

my_deque.push_back(5);
my_deque.push_back(8);

// deque now stores: |11|2|5|8|
\endcode


### Access elements

To return a reference to the element at the start of the deque, call front(), to return a reference to the elemtent at the end of the deque, call back() on a deque instance. 

\code
std::cout << "return 'first' element: " << my_deque.front() << std::endl;  // prints 11 
std::cout << "return 'last' element: " << my_deque.back() << std::endl;  // prints 8
\endcode

Accessing elements at random is supported by the STXXL deque with the []-operator like the following.

\code
std::cout << "random access: " << my_deque[2] << std::endl;  // prints 5
\endcode

The operations described in this sections are not I/O-efficient as they come with \f$\mathcal{O}(1)\f$ time per I/O-access. To achieve I/O-efficient scanning, the STXXL deque provides different iterators. 
The simplest iterator can be used as follows:

\code
// create forward-iterator (which advances from start to end)
stxxl::deque_iterator<deque> deque_iterator = my_deque.begin(); 
// access item at current iterator position
std::cout << *deque_iterator << std::endl;  
// move up one step by preincrement
++deque_iterator;
\endcode

### Delete elements 

Deleting elements is possible at both endings of the deque by using pop_front() and pop_back():

\code
my_deque.pop_front();  // deque now stores: |2|5|8|
my_deque.pop_back();  // deque now stores: |2|5|
\endcode


### Determine size / Check whether the deque is empty

To determine the size (i.e. the number of elements) of an instance, call size():

\code
std::cout << "deque stores: " << my_deque.size() << " elements" << std::endl;
\endcode

To check if the deque is empty, call empty() which returns true if the deque is empty:

\code
std::cout << "empty deque? " << my_deque.empty() << std::endl;
\endcode

### A minimal example on STXXL's deque 

\snippet deque_minimal1.cpp example

The following page refers to more comprehensive STXXL deque example.

\subpage deque_minimal_example "Example 1 - Identify number of smaller elements"

\page deque_minimal_example Queue Example 1 - Identify number of smaller elements

\snippet deque1.cpp example

*/



/*! \page tutorial_pqueue Priority Queue Tutorial

This page introduces into the stxxl::priority_queue container (to learn more about the structure of stxxl::priority_queue, see section \ref design_pqueue).

Basically, the priority queue provides insertion of new elements as well as access and deletion of the element on top.
The invariant guarantees that the top element is the largest (or smallest if desired) of all inserted elements identified by comparison realized by the customizable comparator class. 

### Creating a STXXL priority queue

To manage the configuration of the priority queue type, we use the generator template stxxl::PRIORITY_QUEUE_GENERATOR. This generator template expects a value type (which is an integer in our example), 
a class which we name Comparator(a,b) to compare two given elements a and b, a internal memory limit in bytes and the number of elements to be stored (in 1024 units).

Thus the definition may look as follows:

\code 
// template parameter <value_type, CompareType, internal_memory_limit, number_of_elements> 
typedef stxxl::PRIORITY_QUEUE_GENERATOR<int, ComparatorGreater, 64*1024*1024, 1024*1024>::result pqueue_type;
\endcode

The ComparatorGreater(a,b) class is needed to compare two given elements a and b and has to be defined by hand (and before the priority queue definition above):

\code 
struct ComparatorGreater
{
  bool operator () (const int &a, const int &b) const 
  { return (a>b); }

  int min_value() const
  { return (std::numeric_limits<int>::max) (); }
};
\endcode

The compare-operator () of two elements a and b returns true, if a is larger than b, otherwise false. Consequently, this priority queue serves it's smallest element on top. The additional min_value() function ensures that Comparator(min_value(),x) is true for each and every x.

Likewise the minimum-on-top Comparator, we can easily define a maximum-on-top Comparator which stores the the largest contained integer on top as well: 

\code
struct ComparatorLess
{
  bool operator () (const int & a, const int & b) const 
  { return a<b; }

  int min_value() const 
  { return std::numeric_limits<int>::min(); }
};
\endcode

Note that CompareType must define a <em>strict weak ordering</em>.
For more information on stxxl::PRIORITY_QUEUE_GENERATOR's parameters, see TODO for further information.  

To create a STXXL priority queue instance, a resizable buffered writing and prefetched reading pool expected (to overlap I/O and computation):

\code 
  typedef pqueue_type::block_type block_type;
  const unsigned int mem_for_pools = 16 * 1024 * 1024;  // restricts memory consumption of the pools

  stxxl::read_write_pool<block_type> pool((mem_for_pools / 2) / block_type::raw_size, (mem_for_pools / 2) / block_type::raw_size);
  pqueue_type my_pqueue(pool);  // creates priority queue with read-write-pool
\endcode


### Insert / Access / Delete elements

To insert a new element into the priority queue, call push():

\code
my_pqueue.push(5);
\endcode

The priority queue only allows to access the top element, which is the smallest or largest element (depending on the used comparator class) of all inserted elements. 
Calling top() on an instance returns this element:

\code
int x; 
x = my_pqueue.top(); 
\endcode

Erasing elements is only possible on the top of the priority queue by calling pop().
Note that after removing the element on top, the priority queue still holds the above mentioned property. 

\code
my_pqueue.pop();
\endcode

### Determine size / Check whether the priority queue is empty

To determine the size (i.e. the number of elements) of an instance, call size():
\code
std::cout << "priority queue stores: " << my_pqueue.size() << " elements" << std::endl;
\endcode

To check if the priority queue is empty, call empty() which returns true if so:
\code
std::cout << "empty priority queue? " << my_pqueue.empty() << std::endl;
\endcode

### A minimal working example of STXXL's priority queue 

\snippet pqueue_minimal1.cpp example

The following page refers to a more comprehensive STXXL priority queue example.

\subpage priority_queue_example "Priority Queue Example 1 - TODO"
\page priority_queue_example Priority Queue Example 1 - TODO
*/


/*! \page tutorial_map Map (B+-tree) Tutorial

This page introduces into the external associative container stxxl::map (for further information on the structure you may have a look at \ref design_map). 


### Creating a STXXL Map



\code
#define DATA_NODE_BLOCK_SIZE (4096)
#define DATA_LEAF_BLOCK_SIZE (4096)
...
typedef stxxl::map<int, int, CompareGreater, DATA_NODE_BLOCK_SIZE, DATA_LEAF_BLOCK_SIZE> map_type;
map_type my_map((map_type::node_block_type::raw_size) * (3, map_type::leaf_block_type::raw_size * 3));
\endcode


*/

/*! \page tutorial_matrix Matrix Tutorial

This page introduces into the stxxl::matrix Container.

*/

} // namespace stxxl
