/*! \page external_stack stxxl::stack

The \c S<small>TXXL</small> provides an I/O-efficient stack implementation stxxl::stack as the perhaps simplest external memory data structure. 
\c S<small>TXXL</small> stacks are last in first out (LIFO), i.e. the element on top is the element added (pushed) most recently. 
To access elements below, the overlying elements have to be popped. The basic idea is to buffer the top k elements (k <= 2B) in internal memory,
If the buffers get empty on a number of removal calls, one block is brought from the external memory to the buffers.
Therefore at least B removals are required to make one I/O reading a block. Insertions cause no I/Os until the internal buffers full up.
If this case, one has make extra space and the first B elements are written to the disk. Thus a block write happens only after at least B insertions.
Consequently, the amortized I/O complexity for push and pop stack operations is O(1/DB).

\section stack_architecture The Architecture of stxxl::stack

TODO grafik (?)


\section design_stack_generator stxxl::STACK_GENERATOR 

Besides the type of the elements stxxl::stack has many other template parameters (block size, number of blocks per page, pager class, etc.). To make the configuration of the stack type easier STXXL provides 
special type generator template meta programs for its containers.

The meta-program for stxxl::stack is called stxxl::STACK_GENERATOR.

\code
// Example of use
typedef stxxl::STACK_GENERATOR<int>::result stack_type;
stack_type my_stack;
stack.push(8);
assert(my_stack.size() == 1 && !my_stack.empty() && my_stack.top() == 8);
stack.pop();
assert(my_stack.size() == 0 && my_stack.empty());
\endcode 

The stxxl::STACK_GENERATOR expects the following template parameters in exactly the same order.

\copydetails stxxl::STACK_GENERATOR

\section advanced_stack_section Advanced variants of stxxl::stack

The \c S<small>TXXL</small> library contains four different variants of stacks, each implementation is specialized for a certain access pattern to gain a significant speedup. 

1. \b normal_stack is a general purpose implementation which is the best if the access pattern to the stack is an irregular mix of 
push'es and pop's, i.e. the stack grows and shrinks without a certain rule.

2. \b grow_shrink stack is a stack that is optimized for an access pattern where the insertions are (almost) not intermixed with the removals, and/or vice versa,
the removals are (almost) not intermixed with the insertions. In short, the stack first grows to its maximal size, then shrinks, then grow again and so on, a pattern which can be described by \f$(push^{r_i}, push^{r_j})^k\f$ with \f$1 \leq j \leq k\f$ and large values for \f$r_i\f$ and \f$r_j\f$.

3. \b grow_shrink2 stack is a "grow-shrink" stack that allows the use of common prefetch and write buffer pools. 
   The pools are shared between several "grow-shrink" stacks.
\code
// define grow_shrink2 stack
typedef stxxl::STACK_GENERATOR<int, stxxl::external, stxxl::grow_shrink2, 4, 1*1024*1024, stxxl::RC>::result simple_stack;
  
// prefetch/write pool with 10 blocks prefetching and 10 block write cache (> D is recommended)
stxxl::read_write_pool<simple_stack::block_type> pool(10, 10);

// create a stack with prefetch aggressiveness of 0
external_stack a_stack(pool, 0);

// to give the hint that shrinking is imminent, always prefetch 5 buffers by setting prefetch aggressiveness to 5
a_stack.set_prefetch_aggr(5);
\endcode
\n

4. \b migrating stack is a stack that migrates from internal memory to external memory when its size exceeds a certain threshold (determined by parameter migrating_critical_size). 
  \code 
  // migrating stack example with threshold of 100000
  int t = 1000000;
  typedef stxxl::STACK_GENERATOR<int, stxxl::migrating, stxxl::normal, 4, 1*1024*1024, std::stack<int>, t>::result mig_stack;
  mig_stack m_stack(); 
  \endcode

*/