// -*- mode: c++; mode: visual-line; mode: flyspell; fill-column: 100000 -*-
/***************************************************************************
 *  doc/tutorial_vector_buf.dox
 *
 *  Part of the STXXL. See http://stxxl.sourceforge.net
 *
 *  Copyright (C) 2013 Timo Bingmann <tb@panthema.net>
 *
 *  Distributed under the Boost Software License, Version 1.0.
 *  (See accompanying file LICENSE_1_0.txt or copy at
 *  http://www.boost.org/LICENSE_1_0.txt)
 **************************************************************************/

namespace stxxl {

/** \page tutorial_vector_buf Efficient Sequential Reading and Writing to Vectors

\author Timo Bingmann (2013)

The stxxl::vector is a very versatile container and it allows sequential access loops like the following:

\snippet examples/containers/vector_buf.cpp iterator

These sequential loops, however, are <b>not very efficient</b> as they do not use overlapped I/O. Instead each \c operator[] is processed by the vector paging mechanism, possibly updating the internal paging algorithm's state. Obviously, sequential access to external memory should be done more efficiently. For this purpose STXXL provides buffered reading and writing to vector ranges. These utilized asynchronous I/O and will thus <b>will overlap I/O with computation</b>.

The two basic classes to efficiently read and write vector are vector_bufreader and vector_bufwriter. Their interface is a combination of the \c stream interface and iostreams. The two classes are more conveniently accessible via vector::bufreader_type and vector::bufwriter_type.

\snippet examples/containers/vector_buf.cpp buffered

When using vector_bufreader the vector's size \a should be allocated in advance. However, this is not required: when reaching the end of the vector, the buffered reader will automatically double the vector's size. Thus writing will not produce segfaults; however, doubling may go wrong for huge vectors.

Note that the same efficiency can be achieved using stream function: stream::vector_iterator2stream and stream::materialize also use overlapping I/O.

As last method, which is currently supported by STXXL, one can iterate over the vector using C++11's auto loop construct:

\snippet examples/containers/vector_buf.cpp cxx11

Note that we must construct a buffered reader explicitly, because just writing \c vec would amount to using the usual iterators (with pager). Support for C++11 is still experimental.

All source code from this example is available in \ref examples/containers/vector_buf.cpp. The program also check the sum results and measures the time. The following is an sample result:
\verbatim
[STXXL-MSG] STXXL v1.4.0 (prerelease)
[STXXL-MSG] Disk '/data01/stxxl' is allocated, space: 162124 MiB, I/O implementation: syscall_unlink
[STXXL-MSG] Disk '/data02/stxxl' is allocated, space: 228881 MiB, I/O implementation: syscall_unlink
[STXXL-MSG] In total 2 disks are allocated, space: 391006 MiB
[STXXL-MSG] Starting vector iterator access
sum: 9007199187632128
[STXXL-MSG] Finished vector iterator access after 25.003 seconds
[STXXL-MSG] Starting vector buffered access
sum: 9007199187632128
[STXXL-MSG] Finished vector buffered access after 13.7748 seconds
[STXXL-MSG] Starting vector C++11 loop access
sum: 9007199187632128
[STXXL-MSG] Finished vector C++11 loop access after 13.731 seconds
\endverbatim

Obviously, buffered access to stxxl::vector is a lot more efficient: approx. 13.7 seconds against 24.8.

As a last note: there is also vector_bufreader_reverse and vector::bufreader_reverse for buffered reading in reverse.

\example examples/containers/vector_buf.cpp
This example code is explained in the \ref tutorial_vector_buf section.

\example examples/containers/copy_file.cpp
This is an example of how to copy a file to another using STXXL's asynchronous I/O features.

*/

} // namespace stxxl
